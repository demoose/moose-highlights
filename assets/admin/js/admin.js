// Admin Dashboard JavaScript

const API_BASE = '/api';

// DOM Elements
const booksGrid = document.getElementById('booksGrid');
const addBookBtn = document.getElementById('addBookBtn');
const bookModal = document.getElementById('bookModal');
const bookForm = document.getElementById('bookForm');
const closeModal = document.getElementById('closeModal');
const cancelBtn = document.getElementById('cancelBtn');
const modalTitle = document.getElementById('modalTitle');
const formMode = document.getElementById('formMode');
const toast = document.getElementById('toast');

// State
let books = [];

// Helper: Generate slug from text (lowercase, hyphenated)
function slugify(text) {
  return text
    .toString()
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-')        // Replace spaces with hyphens
    .replace(/[^a-z0-9-]/g, '')  // Remove non-alphanumeric chars except hyphens
    .replace(/-+/g, '-')         // Replace multiple hyphens with single
    .replace(/^-|-$/g, '');      // Remove leading/trailing hyphens
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
  loadBooks();
  setupEventListeners();
});

// Event Listeners
function setupEventListeners() {
  addBookBtn.addEventListener('click', () => openAddModal());
  closeModal.addEventListener('click', () => closeModalHandler());
  cancelBtn.addEventListener('click', () => closeModalHandler());
  bookForm.addEventListener('submit', handleFormSubmit);
  
  // Auto-generate slug from title
  const titleInput = document.getElementById('bookTitle');
  const slugInput = document.getElementById('bookSlug');
  
  titleInput.addEventListener('input', (e) => {
    // Only auto-generate if slug is empty or matches previous auto-generated value
    const currentSlug = slugInput.value;
    const autoSlug = slugify(e.target.value);
    
    // Auto-fill if empty or if it looks like it was auto-generated
    if (!currentSlug || slugInput.dataset.autoGenerated === 'true') {
      slugInput.value = autoSlug;
      slugInput.dataset.autoGenerated = 'true';
    }
  });
  
  // Mark as manually edited if user types in slug field
  slugInput.addEventListener('input', () => {
    slugInput.dataset.autoGenerated = 'false';
  });
  
  // Close modal on backdrop click
  bookModal.addEventListener('click', (e) => {
    if (e.target === bookModal) closeModalHandler();
  });
}

// Load Books
async function loadBooks() {
  booksGrid.innerHTML = '<div class="loading">Loading books...</div>';
  
  try {
    const response = await fetch(`${API_BASE}/books`);
    books = await response.json();
    renderBooks();
  } catch (error) {
    console.error('Error loading books:', error);
    booksGrid.innerHTML = '<div class="empty-state">Failed to load books. Is the server running?</div>';
  }
}

// Render Books Grid
function renderBooks() {
  if (books.length === 0) {
    booksGrid.innerHTML = `
      <div class="empty-state">
        <p>No books yet. Add your first cookbook!</p>
      </div>
    `;
    return;
  }
  
  booksGrid.innerHTML = books.map(book => `
    <article class="book-card" onclick="navigateToBook('${book.slug}')">
      <img 
        class="book-card-cover" 
        src="${book.webp || book.png || '/assets/images/covers/placeholder.png'}" 
        alt="Cover of ${book.title}"
        onerror="this.src='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%23334155%22 width=%22100%22 height=%22100%22/><text x=%2250%22 y=%2255%22 text-anchor=%22middle%22 fill=%22%2394a3b8%22 font-size=%2212%22>No Cover</text></svg>'"
      >
      <div class="book-card-content">
        <h3 class="book-card-title">${book.title}</h3>
        <p class="book-card-author">${book.author}</p>
        <div class="book-card-meta">
          ${book.rating ? `<span>‚≠ê ${book.rating}</span>` : ''}
          ${book.progress ? `<span>üìñ ${book.progress}</span>` : ''}
          <span>üìù ${book.notesCount || 0} notes</span>
        </div>
      </div>
    </article>
  `).join('');
}

// Navigate to book detail page
function navigateToBook(slug) {
  window.location.href = `book.html?slug=${slug}`;
}

// Open Add Modal
function openAddModal() {
  formMode.value = 'add';
  modalTitle.textContent = 'Add New Book';
  bookForm.reset();
  document.getElementById('bookSlug').disabled = false;
  document.getElementById('bookSlug').dataset.autoGenerated = 'true'; // Reset flag
  bookModal.classList.add('active');
}

// Close Modal
function closeModalHandler() {
  bookModal.classList.remove('active');
  bookForm.reset();
}

// Handle Form Submit
async function handleFormSubmit(e) {
  e.preventDefault();
  
  const formData = new FormData(bookForm);
  const slug = slugify(formData.get('slug')); // Normalize the slug
  const coverFile = document.getElementById('bookCover').files[0];
  
  if (!slug) {
    showToast('Invalid slug - must contain letters or numbers', 'error');
    return;
  }
  
  const bookData = {
    slug,
    title: formData.get('title'),
    author: formData.get('author'),
    rating: formData.get('rating'),
    progress: formData.get('progress'),
    bookshop: formData.get('bookshop')
  };
  
  try {
    // Create book
    const response = await fetch(`${API_BASE}/books`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(bookData)
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error || 'Failed to create book');
    }
    
    // Upload cover if provided
    if (coverFile) {
      const coverFormData = new FormData();
      coverFormData.append('cover', coverFile);
      coverFormData.append('slug', slug);
      
      await fetch(`${API_BASE}/upload-cover`, {
        method: 'POST',
        body: coverFormData
      });
    }
    
    showToast('Book created successfully!', 'success');
    closeModalHandler();
    loadBooks();
  } catch (error) {
    console.error('Error creating book:', error);
    showToast(error.message, 'error');
  }
}

// Toast Notification
function showToast(message, type = 'info') {
  toast.textContent = message;
  toast.className = `toast ${type} show`;
  
  setTimeout(() => {
    toast.classList.remove('show');
  }, 3000);
}
